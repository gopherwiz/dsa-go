/*
GEOSPATIAL INDEXING COMPARISON (2026 REFERENCE)
==============================================

1. REDIS GEO (GEOHASH / Z-ORDER CURVE)
--------------------------------------
- Geometry: Recursive Squares/Rectangles.
- Pattern: Z-Order (Morton) Curve - connects cells in a "Z" pattern.
- Logic: "Storage-First" Static Grid. The world is pre-divided into a fixed hierarchy.
- Implementation: Uses 52-bit integer interleaving stored in a Sorted Set (ZSET).
- Hierarchy: 1:4 (Standard Quadtree-style subdivision).
- Recursion: Happens during bit-interleaving.
    * 1 bit = 1 bisection level.
    * 5 bits = 1 Base32 character (for string representation).
    * 52 bits (Redis default) = ~0.6m precision (11-character string).
- Pros: Extremely fast native Redis commands; Zero setup overhead.
- Cons: The "Boundary Jump" Flawâ€”Two points inches apart can have totally different
  hashes if they lie on opposite sides of a major quadrant boundary (Poor Locality).
- Latency:
    Because Redis is entirely in-memory, individual search queries (like GEOSEARCH)
    typically return results in microseconds.
    This is significantly faster than PostGIS (~150ms) or Elasticsearch (~117ms).
- High Throughput:
    A single Redis instance can handle over 100,000 queries per second (QPS).
    In some benchmarks, Redis has shown up to 52x higher throughput
    than general-purpose databases like OpenSearch.
- Ingestion Speed:
    Redis excels at high-frequency updates,
    such as tracking a thousand moving delivery vehicles in real-time,
    because there is no disk I/O overhead for every position update.
- Truncation Strategy:
    11 chars (~15cm): Redis Default (High precision).
    7  chars (~153m): Building/Block level.
    6  chars (~1.2km): Street/Neighborhood level (Ideal for "Cabs nearby").
    5  chars (~4.9km): City District level.

2. UBER H3 (HEXAGONAL HIERARCHICAL INDEX)
-----------------------------------------
- Geometry: Hexagons (projected from a 20-sided icosahedron).
- Pattern: Icosahedral Global Grid.
- Logic: "Analytics-First" Global Grid.
- Adjacency: Equidistant neighbors. All 6 neighbors are the same distance from the center.
- Hierarchy: 1:7 (Aperture-7). Each parent has 7 children (slightly rotated).
- Recursion: Fixed 16 resolutions (Res 0 to 15).
- Storage: 64-bit identifiers (not native to Redis, stored as Strings/Hashes/Ints).
- Pros: Best for spatial smoothing, heatmaps, and ride-sharing supply/demand.
  Preserves spatial locality excellently with no diagonal distance distortion.
- Cons: Requires H3-Go library; more CPU-intensive than Geohash.
- Analytical Speed (Uber H3):
    If your goal is to analyze billions of rows for patterns
    (e.g., "Which city districts have the most traffic over the last month?"),
    analytical engines like Kinetica or CrateDB using H3 are faster
    because they are designed for massive parallel scans rather than simple radius lookups.

3. HILBERT-BASED QUADTREES (S2 GEOMETRY)
----------------------------------------
- Geometry: Recursive Squares projected onto a 3D Cube (6 faces).
- Pattern: Hilbert Space-Filling Curve - connects cells in a continuous "snake-like" U-shape.
- Logic: Optimized Locality. Unlike the Z-pattern, the Hilbert curve is continuous.
- Hierarchy: 1:4 (Recursive indexing). Like a Quadtree, each node has 4 children,
  but they are ordered according to the Hilbert path (0->1->2->3 in a U-shape).
- Storage: 64-bit unsigned integers (S2 Cell IDs).
- Pros:
    * Stable Locality: Points physically close are almost always close on the curve.
    * Flexible Shapes: Superior at "Polygon Covering" (filling irregular shapes like parks).
- Cons: Complexity; requires S2 library; not natively searchable via Redis GEO commands.
- Complex Shape Filtering (S2/Hilbert):
    If you are checking if points fall within highly complex, irregular polygons (like city limits),
    Google's S2 (Hilbert-based) is more efficient at calculating which grid cells cover the shape,
    reducing the amount of redundant data you have to process.

4. POSTGIS (R-TREE / GIST)
--------------------------
- Logic: Disk-based indexing that organizes data into nested bounding boxes.
- Pros: Gold standard for persistent storage and complex topological joins.
- Cons: Bound by Disk I/O; significantly higher latency than in-memory alternatives.

LATENCY & THROUGHPUT ANALYSIS (2026)
------------------------------------
- REDIS: The Latency King. Sub-millisecond response times. Up to 50x faster
  throughput than disk-based GIS (PostGIS/Elasticsearch) due to In-Memory ZSETs.
- S2 (HILBERT): Low-millisecond. Optimized for reducing "false positive"
  candidates in complex geometric searches.
- UBER H3: Moderate-to-Low. Slower for simple point lookups, but fastest for
  aggregating billions of points into analytical buckets.
- PostGIS: Moderate (100ms+). Disk-based R-Tree index.


COMPARISON TABLE
---------------------------------------------------------------------------------------------------------
Feature         | Redis Geohash     | Hilbert (S2)      | Uber H3           | PostGIS (R-Tree)      |
----------------|-------------------|-------------------|-------------------|------------------------|
Pattern         | Z-Order (Morton)  | Hilbert Curve     | Icosahedral Hex   | Bounding Box (GIST)   |
Locality        | Poor (Jumps)      | Excellent (Snake) | Excellent (Equal) | Varies (Tree-based)    |
Cell Shape      | Square/Rectangle  | Square/Rectangle  | Hexagon           | Dynamic / Vector       |
Hierarchy       | 1:4 (Quadtree)    | 1:4 (Continuous)  | 1:7 (Aperture-7)  | N/A (Dynamic Tree)     |
Storage         | In-Memory (ZSET)  | Memory/Disk Int64 | Memory/Disk Int64 | Disk (B-Tree/R-Tree)  |
Latency         | Sub-millisecond   | Low-millisecond   | Moderate-to-Low   | Moderate (100ms+)      |
Primary Speed   | In-memory; 52-bit | Spatial Locality; | Equal-area; No    | Robust Geometry        |
Advantage       | hash lookups      | Continuous Path   | Distortion Math   | Engine Logic           |
Best Use Case   | Real-time "Near"  | Complex Polygons  | Spatial Analytics | Master Record/Joins    |
---------------------------------------------------------------------------------------------------------

SUMMARY FOR IMPLEMENTATION
--------------------------
- Use REDIS NATIVE: For lowest latency real-time tracking (Cabs/Food Delivery).
- Use HILBERT/S2: For complex geofencing where boundary accuracy is critical.
- Use UBER H3: For heatmaps, pricing logic, and large-scale data science.
*/
